# Multi-Project Usage Example: Child Pipeline Inheritance Component
# This example shows how to use the component across multiple projects and environments

include:
  - component: gitlab.example.com/components/child-pipeline-inheritance@v1.0.0
    inputs:
      stage: "orchestration"
      enable_backend_build: "false"     # Disable backend build in orchestrator
      enable_validation: "true"
      docker_image: "ubuntu:22.04"

stages:
  - validate
  - orchestration  # Component runs here
  - cross-project
  - integration

variables:
  # Multi-project configuration
  ORCHESTRATOR_PROJECT: "microservices-orchestrator"
  FRONTEND_PROJECT_ID: "123"
  BACKEND_PROJECT_ID: "456" 
  INFRASTRUCTURE_PROJECT_ID: "789"
  
  # Environment configuration
  TARGET_ENVIRONMENT: "${CI_COMMIT_BRANCH}"
  DEPLOYMENT_STRATEGY: "blue-green"

# Cross-project pipeline triggers
trigger-frontend-pipeline:
  stage: cross-project
  script:
    - eval "$ECHO_FUNCTIONS"
    - log_info "üé® Triggering frontend pipeline"
    - log_debug "Project ID: $FRONTEND_PROJECT_ID"
    - log_debug "Environment: $TARGET_ENVIRONMENT"
  trigger:
    project: group/frontend-service
    branch: $CI_COMMIT_REF_NAME
    strategy: depend
  variables:
    PARENT_ORCHESTRATOR: $CI_PROJECT_NAME
    PARENT_PIPELINE_ID: $CI_PIPELINE_ID
    DEPLOYMENT_ENV: $TARGET_ENVIRONMENT
  rules:
    - if: $CI_PIPELINE_SOURCE == "push"
    - if: $CI_PIPELINE_SOURCE == "schedule"

trigger-backend-pipeline:
  stage: cross-project
  script:
    - eval "$ECHO_FUNCTIONS"
    - log_info "‚öôÔ∏è Triggering backend pipeline"
    - log_debug "Project ID: $BACKEND_PROJECT_ID"
    - log_debug "Strategy: $DEPLOYMENT_STRATEGY"
  trigger:
    project: group/backend-service
    branch: $CI_COMMIT_REF_NAME
    strategy: depend
  variables:
    PARENT_ORCHESTRATOR: $CI_PROJECT_NAME
    PARENT_PIPELINE_ID: $CI_PIPELINE_ID
    DEPLOYMENT_ENV: $TARGET_ENVIRONMENT
    DEPLOYMENT_STRATEGY: $DEPLOYMENT_STRATEGY
  rules:
    - if: $CI_PIPELINE_SOURCE == "push"
    - if: $CI_PIPELINE_SOURCE == "schedule"

trigger-infrastructure-pipeline:
  stage: cross-project
  script:
    - eval "$ECHO_FUNCTIONS"
    - log_info "üèóÔ∏è Triggering infrastructure pipeline"
    - log_debug "Project ID: $INFRASTRUCTURE_PROJECT_ID"
  trigger:
    project: group/infrastructure
    branch: $CI_COMMIT_REF_NAME
    strategy: depend
  variables:
    PARENT_ORCHESTRATOR: $CI_PROJECT_NAME
    PARENT_PIPELINE_ID: $CI_PIPELINE_ID
    TARGET_ENV: $TARGET_ENVIRONMENT
  rules:
    - if: $CI_PIPELINE_SOURCE == "push"
      changes:
        - "infrastructure/**/*"
        - "terraform/**/*"
        - "helm/**/*"
    - if: $CI_PIPELINE_SOURCE == "schedule"

# Integration testing across all services
integration-test-services:
  stage: integration
  image: postman/newman:alpine
  script:
    - eval "$ECHO_FUNCTIONS"
    - log_info "üîó Running cross-service integration tests"
    - log_debug "Testing environment: $TARGET_ENVIRONMENT"
    
    # Wait for downstream pipelines to complete
    - log_debug "Waiting for service deployments to complete..."
    - sleep 30
    
    # Run integration tests
    - newman run integration-tests.json \
        --environment "env-$TARGET_ENVIRONMENT.json" \
        --reporters cli,junit \
        --reporter-junit-export integration-results.xml
    
    - log_info "‚úÖ Cross-service integration tests completed"
  artifacts:
    reports:
      junit: integration-results.xml
    paths:
      - integration-results.xml
    expire_in: 1 week
  needs:
    - trigger-frontend-pipeline
    - trigger-backend-pipeline
    - trigger-infrastructure-pipeline
  rules:
    - if: $CI_PIPELINE_SOURCE == "push"
    - if: $CI_PIPELINE_SOURCE == "schedule"

# Environment health check
health-check-environment:
  stage: integration
  image: alpine:latest
  script:
    - eval "$ECHO_FUNCTIONS"
    - log_info "üè• Performing environment health check"
    - log_debug "Environment: $TARGET_ENVIRONMENT"
    
    - apk add --no-cache curl jq
    
    # Check each service health
    - |
      SERVICES=("frontend" "backend" "api-gateway" "database")
      for service in "${SERVICES[@]}"; do
        log_debug "Checking $service health..."
        URL="https://${service}-${TARGET_ENVIRONMENT}.example.com/health"
        
        if curl -f -s "$URL" | jq -e '.status == "healthy"' > /dev/null; then
          log_info "‚úÖ $service is healthy"
        else
          log_error "‚ùå $service health check failed"
          exit 1
        fi
      done
    
    - log_info "‚úÖ All services are healthy in $TARGET_ENVIRONMENT"
  rules:
    - if: $CI_PIPELINE_SOURCE == "push"
    - if: $CI_PIPELINE_SOURCE == "schedule"

# Deployment notification and summary
deployment-summary:
  stage: integration
  image: alpine:latest
  script:
    - eval "$ECHO_FUNCTIONS"
    - log_info "üìä Multi-Project Deployment Summary"
    - log_info "Orchestrator: $ORCHESTRATOR_PROJECT"
    - log_info "Environment: $TARGET_ENVIRONMENT"
    - log_info "Strategy: $DEPLOYMENT_STRATEGY"
    - log_info "Pipeline ID: $CI_PIPELINE_ID"
    
    # Gather deployment information
    - |
      cat << EOF
      üìã Deployment Details:
      - Frontend Project: $FRONTEND_PROJECT_ID
      - Backend Project: $BACKEND_PROJECT_ID  
      - Infrastructure Project: $INFRASTRUCTURE_PROJECT_ID
      - Target Environment: $TARGET_ENVIRONMENT
      - Deployment Strategy: $DEPLOYMENT_STRATEGY
      - Orchestrator Pipeline: $CI_PIPELINE_URL
      
      üîó Service URLs:
      - Frontend: https://frontend-$TARGET_ENVIRONMENT.example.com
      - Backend API: https://backend-$TARGET_ENVIRONMENT.example.com
      - Admin Portal: https://admin-$TARGET_ENVIRONMENT.example.com
      EOF
    
    - log_info "üéâ Multi-project deployment orchestration completed!"
  rules:
    - when: always

# The component will also generate its own child pipeline that:
# 1. Analyzes changes in the orchestrator project
# 2. Generates appropriate build/test jobs based on detected changes
# 3. Provides standardized logging throughout the child pipeline
# 4. Runs alongside the cross-project orchestration defined above