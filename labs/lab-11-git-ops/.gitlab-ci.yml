# Lab 11: Git Branch Operations from Pipeline
# Demonstrates feature branch creation, code modification, and merge requests

stages:
  - setup
  - update-images
  - commit-changes
  - create-merge-request

variables:
  # Feature branch name with timestamp for uniqueness
  FEATURE_BRANCH: "feature/update-base-images-${CI_PIPELINE_ID}"
  # Target base branch
  BASE_BRANCH: "main"


# Job 1: Setup and create feature branch
setup-branch:
  stage: setup
  image: alpine:latest
  rules:
    # Only run on main branch, exclude merge requests
    - if: '$CI_COMMIT_BRANCH == "main" && $CI_PIPELINE_SOURCE != "merge_request_event"'
    # Manual trigger option
    - if: '$CI_PIPELINE_SOURCE == "web"'
      when: manual
  before_script:
    - apk add --no-cache git
    - git config --global user.email "${GITLAB_USER_EMAIL:-ci@example.com}"
    - git config --global user.name "${GITLAB_USER_NAME:-GitLab CI}"
    - git config --global init.defaultBranch main
  script:
    - echo "Creating feature branch ${FEATURE_BRANCH}"
    - REPO_URL="$(echo ${CI_PROJECT_URL} | sed 's|://|://oauth2:'${ACCESS_TOKEN}'@|')"
    - echo "Repository URL configured - ${REPO_URL}"
    - git remote set-url origin "${REPO_URL}"
    - git fetch origin
    - git checkout -b "${FEATURE_BRANCH}" origin/${BASE_BRANCH}
    - git push -u origin "${FEATURE_BRANCH}" -o ci.skip
    - echo "Feature branch created ${FEATURE_BRANCH}"
    - echo "FEATURE_BRANCH=${FEATURE_BRANCH}" > branch.env
  artifacts:
    reports:
      dotenv: branch.env
    paths:
      - branch.env
    expire_in: 1 hour

# Job 2: Update Docker base images
update-docker-images:
  stage: update-images
  image: alpine:latest
  needs: ["setup-branch"]
  dependencies:
    - setup-branch
  rules:
    - if: '$CI_COMMIT_BRANCH == "main" && $CI_PIPELINE_SOURCE != "merge_request_event"'
    - if: '$CI_PIPELINE_SOURCE == "web"'
      when: manual
  before_script:
    - apk add --no-cache git curl jq
    - git config --global user.email "${GITLAB_USER_EMAIL:-ci@example.com}"
    - git config --global user.name "${GITLAB_USER_NAME:-GitLab CI}"
    - REPO_URL="$(echo ${CI_PROJECT_URL} | sed 's|://|://oauth2:'${ACCESS_TOKEN}'@|')"
    - git remote set-url origin "${REPO_URL}"
  script:
    # Clean up any artifact files that might conflict with git checkout
    - rm -f branch.env changes.env
    - echo "Checking out feature branch ${FEATURE_BRANCH}"
    - git fetch origin
    - git checkout "${FEATURE_BRANCH}"
    
    # Update Docker base images in sample-app/Dockerfile
    - |
      # Define reusable function for updating Docker base images
      update_base_image() {
        local image_name="$1"
        local tag_filter="$2"
        local sort_method="$3"
        local display_name="$4"
        local show_detailed_output="$5"
        
        echo "Querying Docker Hub API for latest $display_name image..."
        local response=$(curl -s "https://registry.hub.docker.com/v2/repositories/library/$image_name/tags/?page_size=100")
        
        if [ $? -eq 0 ] && [ -n "$response" ]; then
          # Extract tags based on the filter pattern
          local latest_tag=$(echo "$response" | grep -o '"name":"[^"]*"' | sed 's/"name":"//g' | sed 's/"//g' | grep -E "$tag_filter" | sort $sort_method | tail -1)
          
          if [ -n "$latest_tag" ]; then
            echo "Latest $display_name tag found - $latest_tag"
            local current_version=$(grep -oE "FROM $image_name:[^[:space:]]+" sample-app/Dockerfile | sed "s/FROM $image_name://" || echo "")
            
            if [ -n "$current_version" ]; then
              echo "Current $display_name version - $current_version"
              echo "Updating $display_name base image from $image_name:$current_version to $image_name:$latest_tag"
              
              # Show detailed output only for the first image (Python)
              if [ "$show_detailed_output" = "true" ]; then
                echo "=== Dockerfile content BEFORE update ==="
                cat sample-app/Dockerfile
                echo "=== END BEFORE ==="
              fi
              
              # Escape special characters in version strings
              local escaped_current=$(echo "$current_version" | sed 's/[[\.*^$()+?{|]/\\&/g')
              local escaped_new=$(echo "$latest_tag" | sed 's/[[\.*^$()+?{|]/\\&/g')
              
              echo "Executing sed command for $display_name update"
              sed -i "s/FROM $image_name:$escaped_current/FROM $image_name:$escaped_new/g" sample-app/Dockerfile
              
              # Show detailed output only for the first image (Python)
              if [ "$show_detailed_output" = "true" ]; then
                echo "=== Dockerfile content AFTER update ==="
                cat sample-app/Dockerfile
                echo "=== END AFTER ==="
              fi
              
              # Verify the change was made
              if grep -q "FROM $image_name:$latest_tag" sample-app/Dockerfile; then
                echo "✓ $display_name base image successfully updated to $latest_tag"
              else
                echo "✗ ERROR: $display_name base image update failed"
                grep "FROM $image_name:" sample-app/Dockerfile || echo "No $display_name FROM line found"
              fi
            else
              echo "No $display_name base image found in Dockerfile"
            fi
          else
            echo "Could not parse $display_name tags from API response"
          fi
        else
          echo "Could not fetch $display_name tags from Docker Hub API, keeping current version"
        fi
      }

      if [ -f "sample-app/Dockerfile" ]; then
        echo "Current branch: $(git branch --show-current)"
        echo "Current Dockerfile content:"
        cat sample-app/Dockerfile
        
        # Update Python slim image (with detailed output)
        update_base_image "python" "^[0-9]+\.[0-9]+(\.[0-9]+)?-slim$" "-V" "Python slim" "true"
        
        # Update Node.js LTS image (numeric tags only)
        update_base_image "node" "^[0-9]+$" "-n" "Node.js LTS" "false"
        
        # Update Alpine image (version tags)
        update_base_image "alpine" "^[0-9]+\.[0-9]+(\.[0-9]+)?$" "-V" "Alpine" "false"
        
        echo "Updated Dockerfile content"
        cat sample-app/Dockerfile
        
        # Check if any changes were made
        if git diff --quiet; then
          echo "No changes made to Dockerfile"
        else
          echo "Changes detected in Dockerfile"
        fi
      else
        echo "No Dockerfile found, creating sample files"
        mkdir -p sample-app scripts
        chmod +x scripts/create-sample-files.sh
        ./scripts/create-sample-files.sh
      fi
    
    # Stage changes and check if we have any modifications
    - git add .
    - |
      if git diff --staged --quiet; then
        echo "No staged changes to commit"
        echo "CHANGES_MADE=false" >> changes.env
      else
        echo "Changes staged successfully"
        echo "CHANGES_MADE=true" >> changes.env
        
        # Commit the changes immediately in this job to ensure they persist
        echo "Committing Dockerfile changes in update job"
        git commit -m "chore: update Docker base images
        
        - Updated Python base image version
        - Updated Node.js base image version  
        - Updated Alpine base image version
        
        Automated update via GitLab CI Pipeline ${CI_PIPELINE_ID}"
        
        # Push the changes to the feature branch
        git push origin "${FEATURE_BRANCH}" -o ci.skip
        echo "Changes committed and pushed to ${FEATURE_BRANCH}"
      fi
  artifacts:
    reports:
      dotenv: changes.env
    paths:
      - changes.env
    expire_in: 1 hour

# Job 3: Commit changes to feature branch
commit-changes:
  stage: commit-changes
  image: alpine:latest
  needs: ["setup-branch", "update-docker-images"]
  dependencies:
    - setup-branch
    - update-docker-images
  rules:
    - if: '$CI_COMMIT_BRANCH == "main" && $CI_PIPELINE_SOURCE != "merge_request_event"'
    - if: '$CI_PIPELINE_SOURCE == "web"'
      when: manual
  before_script:
    - apk add --no-cache git
    - git config --global user.email "${GITLAB_USER_EMAIL:-ci@example.com}"
    - git config --global user.name "${GITLAB_USER_NAME:-GitLab CI}"
    - git config --global init.defaultBranch main
  script:
    # Clean up any artifact files that might conflict with git checkout
    - rm -f branch.env changes.env
    - REPO_URL="$(echo ${CI_PROJECT_URL} | sed 's|://|://oauth2:'${ACCESS_TOKEN}'@|')"
    - git remote set-url origin "${REPO_URL}"
    - git fetch origin
    - git checkout "${FEATURE_BRANCH}"
    
    # Check if changes were already committed in the update job
    - |
      if [ "${CHANGES_MADE}" = "true" ]; then
        echo "Changes were already committed in the update-docker-images job"
        echo "Skipping duplicate commit"
        exit 0
      fi
    
    # If for some reason changes weren't committed in update job, handle it here
    - git add .
    - |
      if git diff --staged --quiet; then
        echo "No staged changes to commit"
        exit 0
      fi
    
    # Create commit message (fallback)
    - |
      COMMIT_MESSAGE="chore: update Docker base images
      
      - Updated Python base image version
      - Updated Node.js base image version  
      - Updated Alpine base image version
      
      Automated update via GitLab CI Pipeline ${CI_PIPELINE_ID}"
    
    # Commit changes (fallback)
    - git commit -m "${COMMIT_MESSAGE}"
    
    # Push to feature branch with ci.skip to prevent infinite loops (fallback)
    - git push origin "${FEATURE_BRANCH}" -o ci.skip
    
    - echo "Changes committed and pushed to ${FEATURE_BRANCH}"

# Job 4: Create merge request
create-merge-request:
  stage: create-merge-request
  image: alpine:latest
  needs: ["setup-branch", "update-docker-images", "commit-changes"]
  dependencies:
    - setup-branch
    - update-docker-images
  rules:
    - if: '$CI_COMMIT_BRANCH == "main" && $CI_PIPELINE_SOURCE != "merge_request_event"'
    - if: '$CI_PIPELINE_SOURCE == "web"'
      when: manual
  before_script:
    - apk add --no-cache curl jq git
  script:
    - |
      # Only create MR if changes were made
      if [ "${CHANGES_MADE}" != "true" ]; then
        echo "No changes were made, skipping merge request creation"
        exit 0
      fi
    
    # Create merge request using GitLab API
    - |
      curl --request POST \
        --header "PRIVATE-TOKEN: ${ACCESS_TOKEN}" \
        --header "Content-Type: application/json" \
        --data "{
          \"source_branch\": \"${FEATURE_BRANCH}\",
          \"target_branch\": \"${BASE_BRANCH}\",
          \"title\": \"chore: update Docker base images (automated)\",
          \"description\": \"This merge request was automatically created by GitLab CI/CD pipeline ${CI_PIPELINE_ID}. Updated Docker base image versions in Dockerfiles.\",
          \"remove_source_branch\": true
        }" \
        "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/merge_requests"
    
    - echo "Merge request created for ${FEATURE_BRANCH} -> ${BASE_BRANCH}"

# Cleanup job - runs on failure to clean up feature branches
cleanup-on-failure:
  stage: create-merge-request
  image: alpine:latest
  rules:
    - when: on_failure
  before_script:
    - apk add --no-cache git
  script:
    - git config --global user.email "${GITLAB_USER_EMAIL:-ci@example.com}"
    - git config --global user.name "${GITLAB_USER_NAME:-GitLab CI}"
    - REPO_URL="$(echo ${CI_PROJECT_URL} | sed 's|://|://oauth2:'${ACCESS_TOKEN}'@|')"
    - git remote set-url origin "${REPO_URL}"
    - git fetch origin
    - echo "Cleaning up feature branch ${FEATURE_BRANCH} due to pipeline failure"
    - git push origin --delete "${FEATURE_BRANCH}" || echo "Branch may not exist or already deleted"