# Lab 11: Git Branch Operations from Pipeline
# Demonstrates feature branch creation, code modification, and merge requests

stages:
  - check
  - setup-and-update
  - commit-and-merge-request

variables:
  # Feature branch name with timestamp for uniqueness
  FEATURE_BRANCH: "feature/update-base-images-${CI_PIPELINE_ID}"
  # Target base branch
  BASE_BRANCH: "main"

# Common script blocks to reduce duplication
.scripts:
  git-user-config: &git-user-config
    - git config --global user.email "${GITLAB_USER_EMAIL:-ci@example.com}"
    - git config --global user.name "${GITLAB_USER_NAME:-GitLab CI}"
  
  api-tools-install: &api-tools-install
    - apk add --no-cache curl jq git
  
  docker-image-handler: &docker-image-handler
    - |
      handle_docker_image() {
        local image_name="$1"
        local tag_filter="$2"
        local sort_method="$3"
        local display_name="$4"
        local mode="$5"           # "check" or "update"
        local show_detailed="$6"  # "true" or "false"
        
        echo "$([ "$mode" = "check" ] && echo "Checking for" || echo "Querying Docker Hub API for latest") $display_name $([ "$mode" = "check" ] && echo "updates..." || echo "image...")"
        local response=$(curl -s "https://registry.hub.docker.com/v2/repositories/library/$image_name/tags/?page_size=100")
        
        if [ $? -eq 0 ] && [ -n "$response" ]; then
          # Extract tags based on filter pattern
          local latest_tag=$(echo "$response" | grep -o '"name":"[^"]*"' | sed 's/"name":"//g' | sed 's/"//g' | grep -E "$tag_filter" | sort $sort_method | tail -1)
          
          if [ -n "$latest_tag" ]; then
            echo "Latest $display_name tag $([ "$mode" = "check" ] && echo "available" || echo "found") - $latest_tag"
            
            # Check current version in Dockerfile (if it exists)
            if [ -f "sample-app/Dockerfile" ]; then
              local current_version=$(grep -oE "FROM $image_name:[^[:space:]]+" sample-app/Dockerfile | sed "s/FROM $image_name://" || echo "")
              
              if [ -n "$current_version" ]; then
                echo "Current $display_name version - $current_version"
                
                if [ "$current_version" != "$latest_tag" ]; then
                  if [ "$mode" = "check" ]; then
                    echo "âœ“ Update available - $image_name:$current_version â†’ $image_name:$latest_tag"
                    return 0  # Update needed
                  else
                    echo "Updating $display_name base image from $image_name:$current_version to $image_name:$latest_tag"
                    
                    # Show detailed output if requested
                    if [ "$show_detailed" = "true" ]; then
                      echo "=== Dockerfile content BEFORE update ==="
                      cat sample-app/Dockerfile
                      echo "=== END BEFORE ==="
                    fi
                    
                    # Escape special characters and perform replacement
                    local escaped_current=$(echo "$current_version" | sed 's/[[\.*^$()+?{|]/\\&/g')
                    local escaped_new=$(echo "$latest_tag" | sed 's/[[\.*^$()+?{|]/\\&/g')
                    
                    echo "Executing sed command for $display_name update"
                    sed -i "s/FROM $image_name:$escaped_current/FROM $image_name:$escaped_new/g" sample-app/Dockerfile
                    
                    # Show detailed output if requested
                    if [ "$show_detailed" = "true" ]; then
                      echo "=== Dockerfile content AFTER update ==="
                      cat sample-app/Dockerfile
                      echo "=== END AFTER ==="
                    fi
                    
                    # Verify the change was made
                    if grep -q "FROM $image_name:$latest_tag" sample-app/Dockerfile; then
                      echo "âœ“ $display_name base image successfully updated to $latest_tag"
                      return 0  # Update successful
                    else
                      echo "âœ— ERROR: $display_name base image update failed"
                      grep "FROM $image_name:" sample-app/Dockerfile || echo "No $display_name FROM line found"
                      return 1  # Update failed
                    fi
                  fi
                else
                  echo "$([ "$mode" = "check" ] && echo "- No update needed" || echo "- Already latest") - $image_name:$current_version $([ "$mode" = "check" ] && echo "is already latest" || echo "")"
                  return 1  # No update needed
                fi
              else
                echo "$([ "$mode" = "check" ] && echo "- No" || echo "No") $display_name base image found in Dockerfile"
                return 1  # No update needed
              fi
            else
              if [ "$mode" = "check" ]; then
                echo "- No Dockerfile found, will need to create sample files"
                return 0  # Update needed (file creation)
              else
                echo "No Dockerfile found, creating sample files"
                mkdir -p sample-app scripts
                chmod +x scripts/create-sample-files.sh
                ./scripts/create-sample-files.sh
                return 0  # File creation successful
              fi
            fi
          else
            echo "Could not parse $display_name tags from API response"
            return 1  # No update needed (API issue)
          fi
        else
          echo "Could not fetch $display_name tags from Docker Hub API$([ "$mode" = "check" ] && echo "" || echo ", keeping current version")"
          return 1  # No update needed (API issue)
        fi
      }

# Job 0: Check if Docker image updates are needed
check-updates:
  stage: check
  image: alpine:latest
  rules:
    # Only run on main branch, exclude merge requests
    - if: '$CI_COMMIT_BRANCH == "main" && $CI_PIPELINE_SOURCE != "merge_request_event"'
    # Manual trigger option
    - if: '$CI_PIPELINE_SOURCE == "web"'
      when: manual
  before_script:
    - apk add --no-cache git curl jq
  script:
    - !reference [.scripts, docker-image-handler]
    - |
      # Check all image types for updates
      updates_needed=false

      # Check Python slim image
      if handle_docker_image "python" "^[0-9]+\.[0-9]+(\.[0-9]+)?-slim$" "-V" "Python slim" "check" "false"; then
        updates_needed=true
      fi

      # Check Node.js LTS image
      if handle_docker_image "node" "^[0-9]+$" "-n" "Node.js LTS" "check" "false"; then
        updates_needed=true
      fi

      # Check Alpine image
      if handle_docker_image "alpine" "^[0-9]+\.[0-9]+(\.[0-9]+)?$" "-V" "Alpine" "check" "false"; then
        updates_needed=true
      fi

      # Output results
      if [ "$updates_needed" = "true" ]; then
        echo ""
        echo "ðŸ”„ Docker image updates are available - pipeline will continue"
        echo "UPDATES_NEEDED=true" > updates.env
      else
        echo ""
        echo "âœ… All Docker images are up to date - skipping remaining jobs"
        echo "UPDATES_NEEDED=false" > updates.env
      fi
  artifacts:
    reports:
      dotenv: updates.env
    paths:
      - updates.env
    expire_in: 1 hour

# Job 1: Setup branch and update Docker images (conditional)
setup-and-update:
  stage: setup-and-update
  image: alpine:latest
  needs: ["check-updates"]
  dependencies:
    - check-updates
  rules:
    # Always run on main branch, exclude merge requests
    - if: '$CI_COMMIT_BRANCH == "main" && $CI_PIPELINE_SOURCE != "merge_request_event"'
    # Manual trigger option
    - if: '$CI_PIPELINE_SOURCE == "web"'
      when: manual
  before_script:
    - apk add --no-cache git curl jq
    - !reference [.scripts, git-user-config]
    - git config --global init.defaultBranch main
  script:
    # Check if updates are needed (script-level conditional)
    - |
      if [ "${UPDATES_NEEDED}" != "true" ]; then
        echo "âœ… No Docker image updates needed - skipping branch creation and updates"
        echo "CHANGES_MADE=false" > changes.env
        echo "FEATURE_BRANCH=" > branch.env
        exit 0
      fi

    # Clean up any artifact files that might conflict with git checkout
    - rm -f branch.env changes.env
    
    # Setup repository authentication
    - REPO_URL="$(echo ${CI_PROJECT_URL} | sed 's|://|://oauth2:'${ACCESS_TOKEN}'@|')"
    - echo "Repository URL configured - ${REPO_URL}"
    - git remote set-url origin "${REPO_URL}"
    - git fetch origin
    
    # Create feature branch
    - echo "Creating feature branch ${FEATURE_BRANCH}"
    - git checkout -b "${FEATURE_BRANCH}" origin/${BASE_BRANCH}
    - git push -u origin "${FEATURE_BRANCH}" -o ci.skip
    - echo "Feature branch created ${FEATURE_BRANCH}"
    - echo "FEATURE_BRANCH=${FEATURE_BRANCH}" > branch.env
    
    # Update Docker base images in sample-app/Dockerfile
    - !reference [.scripts, docker-image-handler]
    - |
      if [ -f "sample-app/Dockerfile" ]; then
        echo "Current branch: $(git branch --show-current)"
        echo "Current Dockerfile content:"
        cat sample-app/Dockerfile
        
        # Update Python slim image (with detailed output)
        handle_docker_image "python" "^[0-9]+\.[0-9]+(\.[0-9]+)?-slim$" "-V" "Python slim" "update" "true" || true
        
        # Update Node.js LTS image (numeric tags only)
        handle_docker_image "node" "^[0-9]+$" "-n" "Node.js LTS" "update" "false" || true
        
        # Update Alpine image (version tags)
        handle_docker_image "alpine" "^[0-9]+\.[0-9]+(\.[0-9]+)?$" "-V" "Alpine" "update" "false" || true
        
        echo "Updated Dockerfile content"
        cat sample-app/Dockerfile
        
        # Check if any changes were made
        if git diff --quiet; then
          echo "No changes made to Dockerfile"
        else
          echo "Changes detected in Dockerfile"
        fi
      else
        echo "No Dockerfile found, creating sample files"
        mkdir -p sample-app scripts
        chmod +x scripts/create-sample-files.sh
        ./scripts/create-sample-files.sh
      fi
    
    # Stage changes and check if we have any modifications
    - git add .
    - |
      if git diff --staged --quiet; then
        echo "No staged changes to commit"
        echo "CHANGES_MADE=false" >> changes.env
      else
        echo "Changes staged successfully"
        echo "CHANGES_MADE=true" >> changes.env
        
        # Commit the changes immediately in this job to ensure they persist
        echo "Committing Dockerfile changes in update job"
        git commit -m "chore: update Docker base images
        
        - Updated Python base image version
        - Updated Node.js base image version  
        - Updated Alpine base image version
        
        Automated update via GitLab CI Pipeline ${CI_PIPELINE_ID}"
        
        # Push the changes to the feature branch
        git push origin "${FEATURE_BRANCH}" -o ci.skip
        echo "Changes committed and pushed to ${FEATURE_BRANCH}"
      fi
  artifacts:
    reports:
      dotenv: [branch.env, changes.env]
    paths:
      - branch.env
      - changes.env
    expire_in: 1 hour

# Job 2: Commit changes and create merge request (conditional)
commit-and-merge-request:
  stage: commit-and-merge-request
  image: alpine:latest
  needs: ["check-updates", "setup-and-update"]
  dependencies:
    - check-updates
    - setup-and-update
  rules:
    # Always run on main branch, exclude merge requests
    - if: '$CI_COMMIT_BRANCH == "main" && $CI_PIPELINE_SOURCE != "merge_request_event"'
    # Manual trigger option
    - if: '$CI_PIPELINE_SOURCE == "web"'
      when: manual
  before_script:
    - !reference [.scripts, api-tools-install]
    - !reference [.scripts, git-user-config]
  script:
    # Check if updates were actually made (script-level conditional)
    - |
      if [ "${CHANGES_MADE}" != "true" ]; then
        echo "âœ… No changes were made - skipping commit and merge request creation"
        exit 0
      fi

    # Check if feature branch was created
    - |
      if [ -z "${FEATURE_BRANCH}" ]; then
        echo "âŒ No feature branch was created - cannot proceed with merge request"
        exit 1
      fi

    # The changes were already committed in setup-and-update job, so just create MR
    - echo "ðŸ”„ Creating merge request for ${FEATURE_BRANCH} -> ${BASE_BRANCH}"
    
    # Create merge request using GitLab API
    - |
      curl --request POST \
        --header "PRIVATE-TOKEN: ${ACCESS_TOKEN}" \
        --header "Content-Type: application/json" \
        --data "{
          \"source_branch\": \"${FEATURE_BRANCH}\",
          \"target_branch\": \"${BASE_BRANCH}\",
          \"title\": \"chore: update Docker base images (automated)\",
          \"description\": \"This merge request was automatically created by GitLab CI/CD pipeline ${CI_PIPELINE_ID}. Updated Docker base image versions in Dockerfiles.\",
          \"remove_source_branch\": true
        }" \
        "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/merge_requests"
    
    - echo "âœ… Merge request created for ${FEATURE_BRANCH} -> ${BASE_BRANCH}"

# Cleanup job - runs on failure to clean up feature branches
cleanup-on-failure:
  stage: commit-and-merge-request
  image: alpine:latest
  rules:
    - when: on_failure
  before_script:
    - apk add --no-cache git
  script:
    - git config --global user.email "${GITLAB_USER_EMAIL:-ci@example.com}"
    - git config --global user.name "${GITLAB_USER_NAME:-GitLab CI}"
    - REPO_URL="$(echo ${CI_PROJECT_URL} | sed 's|://|://oauth2:'${ACCESS_TOKEN}'@|')"
    - git remote set-url origin "${REPO_URL}"
    - git fetch origin
    - echo "Cleaning up feature branch ${FEATURE_BRANCH} due to pipeline failure"
    - git push origin --delete "${FEATURE_BRANCH}" || echo "Branch may not exist or already deleted"