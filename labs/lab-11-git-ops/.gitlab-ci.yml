# Lab 11: Git Branch Operations from Pipeline
# Demonstrates feature branch creation, code modification, and merge requests

stages:
  - setup
  - update-images
  - commit-changes
  - create-merge-request

variables:
  # Feature branch name with timestamp for uniqueness
  FEATURE_BRANCH: "feature/update-base-images-${CI_PIPELINE_ID}"
  # Target base branch
  BASE_BRANCH: "main"


# Job 1: Setup and create feature branch
setup-branch:
  stage: setup
  image: alpine:latest
  rules:
    # Only run on main branch, exclude merge requests
    - if: '$CI_COMMIT_BRANCH == "main" && $CI_PIPELINE_SOURCE != "merge_request_event"'
    # Manual trigger option
    - if: '$CI_PIPELINE_SOURCE == "web"'
      when: manual
  before_script:
    - apk add --no-cache git
    - git config --global user.email "${GITLAB_USER_EMAIL:-ci@example.com}"
    - git config --global user.name "${GITLAB_USER_NAME:-GitLab CI}"
    - git config --global init.defaultBranch main
  script:
    - echo "Creating feature branch ${FEATURE_BRANCH}"
    - REPO_URL="$(echo ${CI_PROJECT_URL} | sed 's|://|://oauth2:'${ACCESS_TOKEN}'@|')"
    - echo "Repository URL configured - ${REPO_URL}"
    - git remote set-url origin "${REPO_URL}"
    - git fetch origin
    - git checkout -b "${FEATURE_BRANCH}" origin/${BASE_BRANCH}
    - git push -u origin "${FEATURE_BRANCH}" -o ci.skip
    - echo "Feature branch created ${FEATURE_BRANCH}"
    - echo "FEATURE_BRANCH=${FEATURE_BRANCH}" > branch.env
  artifacts:
    reports:
      dotenv: branch.env
    paths:
      - branch.env
    expire_in: 1 hour

# Job 2: Update Docker base images
update-docker-images:
  stage: update-images
  image: alpine:latest
  needs: ["setup-branch"]
  dependencies:
    - setup-branch
  rules:
    - if: '$CI_COMMIT_BRANCH == "main" && $CI_PIPELINE_SOURCE != "merge_request_event"'
    - if: '$CI_PIPELINE_SOURCE == "web"'
      when: manual
  before_script:
    - apk add --no-cache git curl jq
    - git config --global user.email "${GITLAB_USER_EMAIL:-ci@example.com}"
    - git config --global user.name "${GITLAB_USER_NAME:-GitLab CI}"
    - REPO_URL="$(echo ${CI_PROJECT_URL} | sed 's|://|://oauth2:'${ACCESS_TOKEN}'@|')"
    - git remote set-url origin "${REPO_URL}"
  script:
    - echo "Checking out feature branch ${FEATURE_BRANCH}"
    - git fetch origin
    - git checkout "${FEATURE_BRANCH}"
    
    # Update Docker base images in sample-app/Dockerfile
    - |
      if [ -f "sample-app/Dockerfile" ]; then
        echo "Current branch: $(git branch --show-current)"
        echo "Current Dockerfile content:"
        cat sample-app/Dockerfile
        
        # Query Docker Hub API for latest Python slim image
        echo "Querying Docker Hub API for latest Python slim image..."
        PYTHON_RESPONSE=$(curl -s "https://registry.hub.docker.com/v2/repositories/library/python/tags/?page_size=100")
        if [ $? -eq 0 ] && [ -n "$PYTHON_RESPONSE" ]; then
          # Extract slim tags using grep and sed, then sort to get latest
          PYTHON_TAGS=$(echo "$PYTHON_RESPONSE" | grep -o '"name":"[^"]*-slim"' | sed 's/"name":"//g' | sed 's/"//g' | grep -E '^[0-9]+\.[0-9]+(\.[0-9]+)?-slim$' | sort -V | tail -1)
          
          if [ -n "$PYTHON_TAGS" ]; then
            echo "Latest Python slim tag found - $PYTHON_TAGS"
            CURRENT_PYTHON=$(grep -oE 'FROM python:[^[:space:]]+' sample-app/Dockerfile | sed 's/FROM python://' || echo "")
            if [ -n "$CURRENT_PYTHON" ]; then
              echo "Current Python version - $CURRENT_PYTHON"
              echo "Updating Python base image from python:$CURRENT_PYTHON to python:$PYTHON_TAGS"
              
              # Show content before change
              echo "=== Dockerfile content BEFORE update ==="
              cat sample-app/Dockerfile
              echo "=== END BEFORE ==="
              
              # Escape special characters and perform replacement
              ESCAPED_CURRENT=$(echo "$CURRENT_PYTHON" | sed 's/[[\.*^$()+?{|]/\\&/g')
              ESCAPED_NEW=$(echo "$PYTHON_TAGS" | sed 's/[[\.*^$()+?{|]/\\&/g')
              echo "Executing sed command for Python update"
              sed -i "s/FROM python:$ESCAPED_CURRENT/FROM python:$ESCAPED_NEW/g" sample-app/Dockerfile
              
              # Show content after change and verify
              echo "=== Dockerfile content AFTER update ==="
              cat sample-app/Dockerfile
              echo "=== END AFTER ==="
              
              # Verify the change was made
              if grep -q "FROM python:$PYTHON_TAGS" sample-app/Dockerfile; then
                echo "✓ Python base image successfully updated to $PYTHON_TAGS"
              else
                echo "✗ ERROR: Python base image update failed - still contains old version"
                grep "FROM python:" sample-app/Dockerfile || echo "No Python FROM line found"
              fi
            else
              echo "No Python base image found in Dockerfile"
            fi
          else
            echo "Could not parse Python slim tags from API response"
          fi
        else
          echo "Could not fetch Python tags from Docker Hub API, keeping current version"
        fi
        
        # Query Docker Hub API for latest Node.js LTS image
        echo "Querying Docker Hub API for latest Node.js LTS image..."
        NODE_RESPONSE=$(curl -s "https://registry.hub.docker.com/v2/repositories/library/node/tags/?page_size=100")
        if [ $? -eq 0 ] && [ -n "$NODE_RESPONSE" ]; then
          # Extract numeric tags (LTS versions) and get the latest
          NODE_TAGS=$(echo "$NODE_RESPONSE" | grep -o '"name":"[0-9][0-9]*"' | sed 's/"name":"//g' | sed 's/"//g' | sort -n | tail -1)
          
          if [ -n "$NODE_TAGS" ]; then
            echo "Latest Node.js LTS tag found - $NODE_TAGS"
            CURRENT_NODE=$(grep -oE 'FROM node:[^[:space:]]+' sample-app/Dockerfile | sed 's/FROM node://' || echo "")
            if [ -n "$CURRENT_NODE" ]; then
              echo "Current Node.js version - $CURRENT_NODE"
              echo "Updating Node.js base image from node:$CURRENT_NODE to node:$NODE_TAGS"
              
              # Escape special characters and perform replacement
              ESCAPED_CURRENT_NODE=$(echo "$CURRENT_NODE" | sed 's/[[\.*^$()+?{|]/\\&/g')
              ESCAPED_NEW_NODE=$(echo "$NODE_TAGS" | sed 's/[[\.*^$()+?{|]/\\&/g')
              echo "Executing sed command for Node.js update"
              sed -i "s/FROM node:$ESCAPED_CURRENT_NODE/FROM node:$ESCAPED_NEW_NODE/g" sample-app/Dockerfile
              
              # Verify the change was made
              if grep -q "FROM node:$NODE_TAGS" sample-app/Dockerfile; then
                echo "✓ Node.js base image successfully updated to $NODE_TAGS"
              else
                echo "✗ ERROR: Node.js base image update failed"
                grep "FROM node:" sample-app/Dockerfile || echo "No Node.js FROM line found"
              fi
            else
              echo "No Node.js base image found in Dockerfile"
            fi
          else
            echo "Could not parse Node.js tags from API response"
          fi
        else
          echo "Could not fetch Node.js tags from Docker Hub API, keeping current version"
        fi
        
        # Query Docker Hub API for latest Alpine image
        echo "Querying Docker Hub API for latest Alpine image..."
        ALPINE_RESPONSE=$(curl -s "https://registry.hub.docker.com/v2/repositories/library/alpine/tags/?page_size=100")
        if [ $? -eq 0 ] && [ -n "$ALPINE_RESPONSE" ]; then
          # Extract version tags and get the latest
          ALPINE_TAGS=$(echo "$ALPINE_RESPONSE" | grep -o '"name":"[0-9][^"]*"' | sed 's/"name":"//g' | sed 's/"//g' | grep -E '^[0-9]+\.[0-9]+(\.[0-9]+)?$' | sort -V | tail -1)
          
          if [ -n "$ALPINE_TAGS" ]; then
            echo "Latest Alpine tag found - $ALPINE_TAGS"
            CURRENT_ALPINE=$(grep -oE 'FROM alpine:[^[:space:]]+' sample-app/Dockerfile | sed 's/FROM alpine://' || echo "")
            if [ -n "$CURRENT_ALPINE" ]; then
              echo "Current Alpine version - $CURRENT_ALPINE"
              echo "Updating Alpine base image from alpine:$CURRENT_ALPINE to alpine:$ALPINE_TAGS"
              
              # Escape special characters and perform replacement
              ESCAPED_CURRENT_ALPINE=$(echo "$CURRENT_ALPINE" | sed 's/[[\.*^$()+?{|]/\\&/g')
              ESCAPED_NEW_ALPINE=$(echo "$ALPINE_TAGS" | sed 's/[[\.*^$()+?{|]/\\&/g')
              echo "Executing sed command for Alpine update"
              sed -i "s/FROM alpine:$ESCAPED_CURRENT_ALPINE/FROM alpine:$ESCAPED_NEW_ALPINE/g" sample-app/Dockerfile
              
              # Verify the change was made
              if grep -q "FROM alpine:$ALPINE_TAGS" sample-app/Dockerfile; then
                echo "✓ Alpine base image successfully updated to $ALPINE_TAGS"
              else
                echo "✗ ERROR: Alpine base image update failed"
                grep "FROM alpine:" sample-app/Dockerfile || echo "No Alpine FROM line found"
              fi
            else
              echo "No Alpine base image found in Dockerfile"
            fi
          else
            echo "Could not parse Alpine tags from API response"
          fi
        else
          echo "Could not fetch Alpine tags from Docker Hub API, keeping current version"
        fi
        
        echo "Updated Dockerfile content"
        cat sample-app/Dockerfile
        
        # Check if any changes were made
        if git diff --quiet; then
          echo "No changes made to Dockerfile"
        else
          echo "Changes detected in Dockerfile"
        fi
      else
        echo "No Dockerfile found, creating sample files"
        mkdir -p sample-app scripts
        chmod +x scripts/create-sample-files.sh
        ./scripts/create-sample-files.sh
      fi
    
    # Stage changes and check if we have any modifications
    - git add .
    - |
      if git diff --staged --quiet; then
        echo "No staged changes to commit"
        echo "CHANGES_MADE=false" >> changes.env
      else
        echo "Changes staged successfully"
        echo "CHANGES_MADE=true" >> changes.env
      fi
  artifacts:
    reports:
      dotenv: changes.env
    paths:
      - changes.env
    expire_in: 1 hour

# Job 3: Commit changes to feature branch
commit-changes:
  stage: commit-changes
  image: alpine:latest
  needs: ["setup-branch", "update-docker-images"]
  dependencies:
    - setup-branch
    - update-docker-images
  rules:
    - if: '$CI_COMMIT_BRANCH == "main" && $CI_PIPELINE_SOURCE != "merge_request_event"'
    - if: '$CI_PIPELINE_SOURCE == "web"'
      when: manual
  before_script:
    - apk add --no-cache git
    - git config --global user.email "${GITLAB_USER_EMAIL:-ci@example.com}"
    - git config --global user.name "${GITLAB_USER_NAME:-GitLab CI}"
    - git config --global init.defaultBranch main
  script:
    - REPO_URL="$(echo ${CI_PROJECT_URL} | sed 's|://|://oauth2:'${ACCESS_TOKEN}'@|')"
    - git remote set-url origin "${REPO_URL}"
    - git fetch origin
    - git checkout "${FEATURE_BRANCH}"
    
    # Check if there are changes to commit
    - |
      if git diff --staged --quiet; then
        echo "No staged changes to commit"
        exit 0
      fi
    
    # Create commit message
    - |
      COMMIT_MESSAGE="chore: update Docker base images
      
      - Updated Python base image version
      - Updated Node.js base image version  
      - Updated Alpine base image version
      
      Automated update via GitLab CI Pipeline ${CI_PIPELINE_ID}"
    
    # Commit changes
    - git commit -m "${COMMIT_MESSAGE}"
    
    # Push to feature branch with ci.skip to prevent infinite loops
    - git push origin "${FEATURE_BRANCH}" -o ci.skip
    
    - echo "Changes committed and pushed to ${FEATURE_BRANCH}"

# Job 4: Create merge request
create-merge-request:
  stage: create-merge-request
  image: alpine:latest
  needs: ["setup-branch", "update-docker-images", "commit-changes"]
  dependencies:
    - setup-branch
    - update-docker-images
  rules:
    - if: '$CI_COMMIT_BRANCH == "main" && $CI_PIPELINE_SOURCE != "merge_request_event"'
    - if: '$CI_PIPELINE_SOURCE == "web"'
      when: manual
  before_script:
    - apk add --no-cache curl jq git
  script:
    - |
      # Only create MR if changes were made
      if [ "${CHANGES_MADE}" != "true" ]; then
        echo "No changes were made, skipping merge request creation"
        exit 0
      fi
    
    # Create merge request using GitLab API
    - |
      curl --request POST \
        --header "PRIVATE-TOKEN: ${ACCESS_TOKEN}" \
        --header "Content-Type: application/json" \
        --data "{
          \"source_branch\": \"${FEATURE_BRANCH}\",
          \"target_branch\": \"${BASE_BRANCH}\",
          \"title\": \"chore: update Docker base images (automated)\",
          \"description\": \"This merge request was automatically created by GitLab CI/CD pipeline ${CI_PIPELINE_ID}. Updated Docker base image versions in Dockerfiles.\",
          \"remove_source_branch\": true
        }" \
        "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/merge_requests"
    
    - echo "Merge request created for ${FEATURE_BRANCH} -> ${BASE_BRANCH}"

# Cleanup job - runs on failure to clean up feature branches
cleanup-on-failure:
  stage: create-merge-request
  image: alpine:latest
  rules:
    - when: on_failure
  before_script:
    - apk add --no-cache git
  script:
    - git config --global user.email "${GITLAB_USER_EMAIL:-ci@example.com}"
    - git config --global user.name "${GITLAB_USER_NAME:-GitLab CI}"
    - REPO_URL="$(echo ${CI_PROJECT_URL} | sed 's|://|://oauth2:'${ACCESS_TOKEN}'@|')"
    - git remote set-url origin "${REPO_URL}"
    - git fetch origin
    - echo "Cleaning up feature branch ${FEATURE_BRANCH} due to pipeline failure"
    - git push origin --delete "${FEATURE_BRANCH}" || echo "Branch may not exist or already deleted"