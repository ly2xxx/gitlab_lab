# GitLab Renovate Runner - Modern Pipeline-based Dependency Automation
# Based on official renovate-bot/renovate-runner patterns
# Demonstrates GitLab-native approach vs server-based solutions

stages:
  - validate
  - renovate
  - report

variables:
  # Renovate Configuration
  RENOVATE_BASE_DIR: $CI_PROJECT_DIR/renovate
  RENOVATE_ENDPOINT: $CI_API_V4_URL
  RENOVATE_PLATFORM: gitlab
  RENOVATE_TOKEN: $RENOVATE_TOKEN
  RENOVATE_GITHUB_COM_TOKEN: $GITHUB_COM_TOKEN
  
  # Performance and Logging
  RENOVATE_REPOSITORY_CACHE: enabled
  RENOVATE_OPTIMIZE_FOR_DISABLED: 'true'
  LOG_FILE: renovate-log.ndjson
  LOG_FILE_LEVEL: debug
  LOG_FORMAT: json
  
  # Docker Image
  CI_RENOVATE_IMAGE: ghcr.io/renovatebot/renovate:41
  
  # Repository Discovery (configure as needed)
  # RENOVATE_AUTODISCOVER_FILTER: group/project-name
  # RENOVATE_AUTODISCOVER: true

# Workflow Rules - Control when pipelines run
workflow:
  rules:
    # Don't run for merge requests from renovate branches
    - if: $CI_MERGE_REQUEST_SOURCE_BRANCH_NAME =~ /^renovate\//
      when: never
    # Don't run for push events when MR is open
    - if: $CI_OPEN_MERGE_REQUESTS
      when: never
    # Don't run for tag commits
    - if: $CI_COMMIT_TAG
      when: never
    # Run on schedules (main use case)
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: always
    # Run on manual triggers
    - if: $CI_PIPELINE_SOURCE == "web"
      when: always
    # Default: don't run
    - when: never

# Base template for Renovate jobs
.renovate-base: &renovate-base
  image:
    name: ${CI_RENOVATE_IMAGE}
    pull_policy: always
  cache:
    - key: ${CI_COMMIT_REF_SLUG}-renovate
      paths:
        - renovate/cache/renovate/repository/
    - key: renovate-npm-cache
      paths:
        - .npm/
  before_script:
    - echo "Renovate version $(renovate --version)"
    - echo "Running as user $(whoami) in $(pwd)"
    - echo "GitLab API endpoint - $RENOVATE_ENDPOINT"
  artifacts:
    when: always
    expire_in: 7d
    paths:
      - '$LOG_FILE'
      - 'renovate/logs/'
    reports:
      # Create custom report for dependency updates
      junit: renovate-results.xml

# Validate Renovate Configuration
validate-config:
  stage: validate
  image: node:18-alpine
  script:
    - npm install -g renovate
    - |
      if [ -f "renovate.json" ]; then
        echo "Validating renovate.json"
        renovate-config-validator renovate.json
      else
        echo "No renovate.json found, skipping validation"
      fi
    - |
      if [ -f "config.js" ]; then
        echo "Validating config.js"
        node -c config.js
      else
        echo "No config.js found, skipping validation"  
      fi
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
    - if: $CI_PIPELINE_SOURCE == "web"
    - changes:
        - renovate.json
        - config.js
        - configs/**/*

# Main Renovate Job - Repository Updates
renovate:
  <<: *renovate-base
  stage: renovate
  resource_group: renovate-updates
  timeout: 2h
  script:
    - |
      # Prepare environment
      mkdir -p renovate/logs
      
      # Set repository filter if specified
      if [ -n "$RENOVATE_AUTODISCOVER_FILTER" ]; then
        echo "Using repository filter: $RENOVATE_AUTODISCOVER_FILTER"
        export RENOVATE_AUTODISCOVER_FILTER
      fi
      
      # Run Renovate with autodiscovery
      if [ "$RENOVATE_AUTODISCOVER" = "true" ]; then
        echo "Running Renovate with autodiscovery"
        renovate --autodiscover=true $RENOVATE_EXTRA_FLAGS
      else
        # Run on specific repositories (defined in config or via variables)
        echo "Running Renovate on configured repositories"
        renovate $RENOVATE_EXTRA_FLAGS
      fi
      
      # Generate summary report
      echo "Renovate execution completed at $(date)"
      if [ -f "$LOG_FILE" ]; then
        echo "Log file size: $(wc -l < $LOG_FILE) lines"
        # Extract summary statistics
        grep -c '"level":"info"' "$LOG_FILE" || echo "0 info messages"
        grep -c '"level":"warn"' "$LOG_FILE" || echo "0 warning messages"  
        grep -c '"level":"error"' "$LOG_FILE" || echo "0 error messages"
      fi
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
    - if: $CI_PIPELINE_SOURCE == "web"
  retry:
    max: 2
    when:
      - runner_system_failure
      - stuck_or_timeout_failure

# Dry Run Job - Test Configuration
renovate-dry-run:
  <<: *renovate-base
  stage: renovate
  variables:
    RENOVATE_DRY_RUN: full
  script:
    - echo "Running Renovate in dry-run mode for configuration testing"
    - renovate --dry-run=full $RENOVATE_EXTRA_FLAGS
  rules:
    - if: $CI_PIPELINE_SOURCE == "web"
      variables:
        RENOVATE_DRY_RUN: "full"
    - when: manual
      allow_failure: true

# Repository Onboarding - Setup new repositories
renovate-onboarding:
  <<: *renovate-base
  stage: renovate
  variables:
    RENOVATE_ONBOARDING: 'true'
    RENOVATE_REQUIRE_CONFIG: 'ignored'
  script:
    - echo "Running Renovate onboarding for new repositories"
    - renovate --onboarding=true --require-config=ignored $RENOVATE_EXTRA_FLAGS
  rules:
    - when: manual
      allow_failure: true

# Security Updates Only - High Priority
renovate-security:
  <<: *renovate-base
  stage: renovate
  variables:
    RENOVATE_VULNERABILITY_ALERTS: enabled
    RENOVATE_OSV_VULNERABILITY_ALERTS: 'true'
  script:
    - echo "Running security-focused Renovate updates"
    - renovate --vulnerability-alerts=enabled $RENOVATE_EXTRA_FLAGS
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule" && $RENOVATE_SECURITY_ONLY == "true"
    - when: manual
      allow_failure: true

# Generate Reports
generate-report:
  stage: report
  image: python:3.11-alpine
  dependencies:
    - renovate
  script:
    - |
      if [ ! -f "$LOG_FILE" ]; then
        echo "No log file found, skipping report generation"
        exit 0
      fi
      
      # Install jq for JSON processing
      apk add --no-cache jq
      
      # Generate summary report
      cat > report-generator.py << 'EOF'
      import json
      import sys
      from collections import defaultdict
      
      def generate_report(log_file):
          stats = defaultdict(int)
          repos_updated = set()
          prs_created = []
          errors = []
          
          try:
              with open(log_file, 'r') as f:
                  for line in f:
                      try:
                          entry = json.loads(line.strip())
                          level = entry.get('level', '')
                          msg = entry.get('msg', '')
                          
                          stats[level] += 1
                          
                          if 'repository' in entry:
                              repos_updated.add(entry['repository'])
                          
                          if 'PR created' in msg:
                              prs_created.append(entry)
                          
                          if level == 'error':
                              errors.append(entry)
                              
                      except json.JSONDecodeError:
                          continue
          except FileNotFoundError:
              print("Log file not found")
              return
              
          print("# Renovate Execution Report")
          print(f"- Repositories processed: {len(repos_updated)}")
          print(f"- PRs created: {len(prs_created)}")  
          print(f"- Info messages: {stats['info']}")
          print(f"- Warning messages: {stats['warn']}")
          print(f"- Error messages: {stats['error']}")
          
          if errors:
              print("\n## Errors:")
              for error in errors[:5]:  # Show first 5 errors
                  print(f"- {error.get('msg', 'Unknown error')}")
                  
      if __name__ == "__main__":
          generate_report(sys.argv[1] if len(sys.argv) > 1 else 'renovate-log.ndjson')
      EOF
      
      python report-generator.py "$LOG_FILE" > renovate-report.md
      cat renovate-report.md
  artifacts:
    when: always
    expire_in: 30d
    paths:
      - renovate-report.md
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
    - if: $CI_PIPELINE_SOURCE == "web"
    - when: manual
      allow_failure: true